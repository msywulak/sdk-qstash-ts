{"version":3,"sources":["../src/nextjs.ts"],"names":[],"mappings":"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","sourcesContent":["import type { NextApiHandler, NextApiRequest, NextApiResponse } from \"next\";\nimport { NextRequest, NextFetchEvent, NextResponse } from \"next/server\";\nimport { Receiver } from \"./receiver\";\n\nexport type VerifySignaturConfig = {\n  currentSigningKey?: string;\n  nextSigningKey?: string;\n\n  /**\n   * The url of this api route, including the protocol.\n   *\n   * If you omit this, the url will be automatically determined by checking the `VERCEL_URL` env variable and assuming `https`\n   */\n  url?: string;\n\n  /**\n   * Number of seconds to tolerate when checking `nbf` and `exp` claims, to deal with small clock differences among different servers\n   *\n   * @default 0\n   */\n  clockTolerance?: number;\n};\n\nexport function verifySignature(\n  handler: NextApiHandler,\n  config?: VerifySignaturConfig,\n): NextApiHandler {\n  const currentSigningKey = config?.currentSigningKey ?? process.env.QSTASH_CURRENT_SIGNING_KEY;\n  if (!currentSigningKey) {\n    throw new Error(\n      \"currentSigningKey is required, either in the config or as env variable QSTASH_CURRENT_SIGNING_KEY\",\n    );\n  }\n  const nextSigningKey = config?.nextSigningKey ?? process.env.QSTASH_NEXT_SIGNING_KEY;\n  if (!nextSigningKey) {\n    throw new Error(\n      \"nextSigningKey is required, either in the config or as env variable QSTASH_NEXT_SIGNING_KEY\",\n    );\n  }\n  const receiver = new Receiver({\n    currentSigningKey,\n    nextSigningKey,\n  });\n\n  return async (req: NextApiRequest, res: NextApiResponse) => {\n    // @ts-ignore This can throw errors during vercel build\n    const signature = req.headers[\"upstash-signature\"];\n    if (!signature) {\n      res.status(400);\n      res.send(\"`Upstash-Signature` header is missing\");\n      res.end();\n      return;\n    }\n    if (typeof signature !== \"string\") {\n      throw new Error(\"`Upstash-Signature` header is not a string\");\n    }\n\n    const chunks = [];\n    for await (const chunk of req) {\n      // @ts-ignore\n      chunks.push(typeof chunk === \"string\" ? Buffer.from(chunk) : chunk);\n    }\n    const body = Buffer.concat(chunks).toString(\"utf-8\");\n\n    const isValid = await receiver.verify({\n      signature,\n      body,\n      clockTolerance: config?.clockTolerance,\n    });\n    if (!isValid) {\n      res.status(400);\n      res.send(\"Invalid signature\");\n      res.end();\n      return;\n    }\n\n    try {\n      if (req.headers[\"content-type\"] === \"application/json\") {\n        req.body = JSON.parse(body);\n      } else {\n        req.body = body;\n      }\n    } catch {\n      req.body = body;\n    }\n\n    return handler(req, res);\n  };\n}\n\nexport function verifySignatureEdge(\n  handler: (req: NextRequest, nfe: NextFetchEvent) => NextResponse | Promise<NextResponse>,\n  config?: VerifySignaturConfig,\n) {\n  const currentSigningKey = config?.currentSigningKey ?? process.env.QSTASH_CURRENT_SIGNING_KEY;\n  if (!currentSigningKey) {\n    throw new Error(\n      \"currentSigningKey is required, either in the config or as env variable QSTASH_CURRENT_SIGNING_KEY\",\n    );\n  }\n  const nextSigningKey = config?.nextSigningKey ?? process.env.QSTASH_NEXT_SIGNING_KEY;\n  if (!nextSigningKey) {\n    throw new Error(\n      \"nextSigningKey is required, either in the config or as env variable QSTASH_NEXT_SIGNING_KEY\",\n    );\n  }\n  const receiver = new Receiver({\n    currentSigningKey,\n    nextSigningKey,\n  });\n\n  return async (req: NextRequest, nfe: NextFetchEvent) => {\n    const reqClone = req.clone() as NextRequest;\n    // @ts-ignore This can throw errors during vercel build\n    const signature = req.headers.get(\"upstash-signature\");\n    if (!signature) {\n      return new NextResponse(new TextEncoder().encode(\"`Upstash-Signature` header is missing\"), {\n        status: 403,\n      });\n    }\n    if (typeof signature !== \"string\") {\n      throw new Error(\"`Upstash-Signature` header is not a string\");\n    }\n\n    const body = await req.text();\n    const isValid = await receiver.verify({\n      signature,\n      body,\n      clockTolerance: config?.clockTolerance,\n    });\n    if (!isValid) {\n      return new NextResponse(new TextEncoder().encode(\"invalid signature\"), { status: 403 });\n    }\n\n    let parsedBody: unknown = undefined;\n\n    try {\n      if (req.headers.get(\"content-type\") === \"application/json\") {\n        parsedBody = JSON.parse(body);\n      } else {\n        parsedBody = body;\n      }\n    } catch {\n      parsedBody = body;\n    }\n\n    return handler(reqClone, nfe);\n  };\n}\n"]}